## petter-java Refactoring Decisions:

* **Extensive use of static import** Processing may support multiple tabs but these do not behave like Java classes: every class in every tab is a member of the same higher-level class behind the scenes. As a result, all variables share the same scope and a tab that declares a given object or method needn't be referenced when another tab is attempting to reference the belonging declarations. Converting the project to Java (introducing distinct classes), there becomes a requirement to reference methods and variables between classes. Using static imports (rather than Class.field or Class.method()) minimises changes to references in the rest of the code. For example, rather than needing to prefix every reference to *bgcolor* with *Petter.* (the declaring class), we include *static import bgcolor;* once, at the top of the class that needs to reference *bgcolor*, which preserves each reference to *bgcolor*, without needing to refactor each reference to *Petter.bgcolor*. In opting for static imports, it is hoped that converting future revisions of petter (either pde->java or java->pde) will require less refactoring of references than otherwise.

* **Introduce a static reference to the main PApplet instance.** Similar to the above. As code within the Processing IDE behaves as a single class, each tab can reference the live PApplet implicitly and call functions such as ellipse() because the IDE knows to call these methods on the user's PApplet instance. In Java mode, this is not implicit. The PApplet instance must be explicitly referenced by other classes if they wish to call non-static methods like ellipse() and so on. In the refactor, Petter.java exposes a static reference to the non-static PApplet instance. The PApplet assigns itself (*petter = this;*) to the static reference during *setup()*, so when other classes reference the static reference, they be pointed the running Petter PApplet instance. The alternative is passing the PApplet to other classes in constructors or otherwise but this causes larger disparity between the .pde and .java code bases, hence the static reference approach.

* **All 'color' primitives changed to 'int'.** In the Processing IDE, one can declare color datatypes whose value takes a return value from *color()*, a non-static PApplet method that returns ints. As Java mode does not recognise Processing's color primitive, all color primitives have been changed to int datatypes.

* **All instances of 'boolean(myInt)' changed to 'myInt == 1 ? true : false'.** boolean() is only available in the Processing IDE.

* **All instances of 'int(myBool)' changed to 'myBool == true ? 1 : 0'.**  int() is only available in the Processing IDE.

* **Introduce an explicit PApplet launch to start Petter.** In the Processing IDE, there is a behind-the-scenes, or implicit, call to a static method belonging to the PApplet class to setup and run the user's PApplet instance. When using the Processing library in Java, this needs to be done manually with a call PApplet.main() (located in Petter.java).